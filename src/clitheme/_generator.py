"""
Generator function used in applying themes (should not be invoked directly)
"""
import os,sys
import string
import random
import warnings
try:
    from . import _globalvar
except ImportError: # for test program
    import _globalvar

header_begin=\
    """# clitheme theme info header
    # This file is automatically generated by clitheme and should not be edited
    """

path="" # to be generated by function

def handle_error(message):
    raise SyntaxError(message)
def handle_warning(message):
    # warnings.warn(message,SyntaxWarning)
    print("Warning: {}".format(message))
def recursive_mkdir(path, entry_name, line_number_debug): # recursively generate directories (excluding file itself)
    current_path=path
    current_entry="" # for error output
    for x in entry_name.split()[:-1]:
        current_entry+=x+" "
        current_path+="/"+x
        if os.path.isfile(current_path): # conflict with entry file
            handle_error("Line {}: cannot create subsection \"{}\" because an entry with the same name already exists"\
                .format(str(line_number_debug), current_entry))
        elif os.path.isdir(str(current_path))==False: # directory does not exist
           os.mkdir(current_path) 
def add_entry(path, entry_name, entry_content, line_number_debug): # add entry to where it belongs (assuming recursive_mkdir already completed)
    target_path=path
    for x in entry_name.split():
        target_path+="/"+x
    if os.path.isdir(target_path):
        handle_error("Line {}: cannot create entry \"{}\" because a subsection with the same name already exists"\
            .format(str(line_number_debug),entry_name))
    elif os.path.isfile(target_path):
        handle_warning("Line {}: repeated entry \"{}\", overwriting"\
            .format(str(line_number_debug),entry_name))
    f=open(target_path,'w')
    f.write(entry_content+"\n")
def splitarray_to_string(split_content):
    final=""
    for phrase in split_content:
        final+=phrase+" "
    return final.strip()
def write_infofile(path,filename,content,line_number_debug, header_name_debug):
    if not os.path.isdir(path):
        os.makedirs(path)
    target_path=path+"/"+filename
    if os.path.isfile(target_path):
        handle_warning("Line {}: repeated header info \"{}\", overwriting"\
            .format(str(line_number_debug), header_name_debug))
    f=open(target_path,'w')
    f.write(content+'\n')

def generate_custom_path():
    # Generate a temporary path
    global path
    path=_globalvar.clitheme_temp_root+"/clitheme-temp-"
    for x in range(8):
        path+=random.choice(string.ascii_letters)

# Returns true for success or error message
def generate_data_hierarchy(file_content, custom_path_gen=True, custom_infofile_name="1"):
    """
    Generate the data hierarchy in a temporary directory from a definition file (accessible with _generator.path)

    This function should not be invoked directly unless absolutely necessary.
    """
    if custom_path_gen:
        generate_custom_path()
    if not os.path.exists(path): os.mkdir(path)
    datapath=path+"/"+_globalvar.generator_data_pathname
    if not os.path.exists(datapath): os.mkdir(datapath)
    # headerinfo_file=open(path+"/current-theme.clithemeheader",'x')
    # headerinfo_file.write(header_begin)
    current_status="" # header, main, entry
    linenumber=0
    # To detect repeated blocks
    headerparsed=False
    mainparsed=False
    current_domainapp="" # for in_domainapp and unset_domainapp in main block
    current_entry_name="" # for entry
    current_subsection="" # for in_subsection
    for line in file_content.splitlines():
        linenumber+=1
        phrases=line.split()
        if line.strip()=="" or line.strip()[0]=="#": # if empty line or comment
            continue
        if current_status=="": # expect begin_header or begin_main
            if phrases[0]=="begin_header": 
                if len(phrases)!=1:
                    handle_error("Extra arguments after \"{}\" on line {}".format(phrases[0],str(linenumber)))
                if headerparsed:
                    handle_error("Repeated header block at line {}".format(str(linenumber)))
                current_status="header"
            elif phrases[0]=="begin_main": 
                if len(phrases)!=1:
                    handle_error("Extra arguments after \"{}\" on line {}".format(phrases[0],str(linenumber)))
                if mainparsed:
                    handle_error("Repeated main block at line {}".format(str(linenumber)))
                current_status="main"
            else: handle_error("Unexpected \"{}\" on line {}".format(phrases[0],str(linenumber)))
        elif current_status=="header": # expect name, version, locales, or end_header
            if phrases[0]=="name" or phrases[0]=="version" or phrases[0]=="locales":
                if len(phrases)<2:
                    handle_error("Not enough arguments for {} line at line {}"\
                                 .format(phrases[0],str(linenumber)))
                # headerinfo_file.write(line.strip()+"\n")                
                content=splitarray_to_string(phrases[1:])
                write_infofile( \
                    path+"/"+_globalvar.generator_info_pathname+"/"+custom_infofile_name, \
                    "clithemeinfo_"+phrases[0],\
                    content,linenumber,phrases[0]) # e.g. [...]/theme-info/1/clithemeinfo_name
            elif phrases[0]=="end_header": 
                if len(phrases)!=1:
                    handle_error("Extra arguments after \"{}\" on line {}".format(phrases[0],str(linenumber)))
                current_status=""
                headerparsed=True
            else: handle_error("Unexpected \"{}\" on line {}".format(phrases[0],str(linenumber)))
        elif current_status=="main": # expect entry, in_domainapp, unset_domainapp, end_main
            if phrases[0]=="entry":
                if len(phrases)<2:
                    handle_error("Not enough arguments for {} line at line {}"\
                                 .format(phrases[0],str(linenumber)))
                # Prevent leading . & prevent /,\ in entry name
                if _globalvar.sanity_check(splitarray_to_string(phrases[1:]))==False:
                    handle_error("Line {}: entry subsections/names {}".format(str(linenumber),_globalvar.sanity_check_error_message))
                entry_name=splitarray_to_string(phrases[1:]) # generate entry name
                if current_subsection!="": entry_name=current_subsection+" "+entry_name
                if current_domainapp!="": entry_name=current_domainapp+" "+entry_name
                recursive_mkdir(datapath, entry_name, linenumber)
                current_status="entry"
                current_entry_name=entry_name
            elif phrases[0]=="in_domainapp": 
                if len(phrases)!=3:
                    handle_error("Format error in {} at line {}".format(phrases[0],linenumber))
                # sanity check
                if _globalvar.sanity_check(phrases[1]+" "+phrases[2])==False:
                    handle_error("Line {}: domain and app names {}".format(str(linenumber), _globalvar.sanity_check_error_message))
                current_domainapp=phrases[1]+" "+phrases[2]
                current_subsection=""
            elif phrases[0]=="in_subsection":
                if len(phrases)<2:
                    handle_error("Format error in {} at line {}".format(phrases[0],linenumber))
                # check if in_domainapp is set
                if current_domainapp=="":
                    handle_error("Line {}: in_subsection used before in_domainapp".format(linenumber))
                # sanity check
                if _globalvar.sanity_check(splitarray_to_string(phrases[1:]))==False:
                    handle_error("Line {}: subsection names {}".format(str(linenumber), _globalvar.sanity_check_error_message))
                current_subsection=splitarray_to_string(phrases[1:])
            elif phrases[0]=="unset_domainapp":
                if len(phrases)!=1:
                    handle_error("Extra arguments after \"{}\" on line {}".format(phrases[0],str(linenumber)))
                current_domainapp=""
                current_subsection=""
            elif phrases[0]=="unset_subsection":
                if len(phrases)!=1:
                    handle_error("Extra arguments after \"{}\" on line {}".format(phrases[0],str(linenumber)))
                current_subsection=""
            elif phrases[0]=="end_main":
                if len(phrases)!=1:
                    handle_error("Extra arguments after \"{}\" on line {}".format(phrases[0],str(linenumber)))
                current_status=""
                mainparsed=True
            else: handle_error("Unexpected \"{}\" on line {}".format(phrases[0],str(linenumber)))
        elif current_status=="entry": # expect locale, end_entry
            if phrases[0]=="locale":
                if len(phrases)<3:
                    handle_error("Not enough arguments for {} line at line {}"\
                                 .format(phrases[0],str(linenumber)))
                content=splitarray_to_string(phrases[2:])
                target_entry=current_entry_name
                if phrases[1]!="default":
                    target_entry+="__"+phrases[1]
                add_entry(datapath,target_entry,content,linenumber)
            elif phrases[0]=="end_entry":
                if len(phrases)!=1:
                    handle_error("Extra arguments after \"{}\" on line {}".format(phrases[0],str(linenumber)))
                current_status="main"
            else: handle_error("Unexpected \"{}\" on line {}".format(phrases[0],str(linenumber)))
    if not headerparsed or not mainparsed:
        handle_error("Missing or incomplete header or main block")
    # Update current theme index
    theme_index=open(path+"/"+_globalvar.generator_info_pathname+"/"+_globalvar.generator_index_filename, 'w')
    theme_index.write(custom_infofile_name+"\n")
    return True # Everything is successul! :)