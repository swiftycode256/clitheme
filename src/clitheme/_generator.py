"""
Generator function used in applying themes (should not be invoked directly)
"""
import os
import string
import random
import re
try:
    from . import _globalvar
    from . import frontend
except ImportError: # for test program
    import _globalvar
    import frontend

path="" # to be generated by function
silence_warn=False

fd=frontend.FetchDescriptor(domain_name="swiftycode", app_name="clitheme", subsections="generator")

def handle_error(message):
    raise SyntaxError(fd.feof("error-str", "Syntax error: {msg}", msg=message))
def handle_warning(message):
    if not silence_warn: print(fd.feof("warning-str", "Warning: {msg}", msg=message))
def recursive_mkdir(path, entry_name, line_number_debug): # recursively generate directories (excluding file itself)
    current_path=path
    current_entry="" # for error output
    for x in entry_name.split()[:-1]:
        current_entry+=x+" "
        current_path+="/"+x
        if os.path.isfile(current_path): # conflict with entry file
            handle_error(fd.feof("subsection-conflict-err", "Line {num}: cannot create subsection \"{name}\" because an entry with the same name already exists", \
                num=str(line_number_debug), name=current_entry))
        elif os.path.isdir(str(current_path))==False: # directory does not exist
           os.mkdir(current_path) 
def add_entry(path, entry_name, entry_content, line_number_debug): # add entry to where it belongs (assuming recursive_mkdir already completed)
    target_path=path
    for x in entry_name.split():
        target_path+="/"+x
    if os.path.isdir(target_path):
        handle_error(fd.feof("entry-conflict-err", "Line {num}: cannot create entry \"{name}\" because a subsection with the same name already exists", \
            num=str(line_number_debug), name=entry_name))
    elif os.path.isfile(target_path):
        handle_warning(fd.feof("repeated-entry-warn", "Line {num}: repeated entry \"{name}\", overwriting", \
            num=str(line_number_debug), name=entry_name))
    f=open(target_path,'w', encoding="utf-8")
    f.write(entry_content+"\n")
def splitarray_to_string(split_content):
    final=""
    for phrase in split_content:
        final+=phrase+" "
    return final.strip()
def write_infofile(path,filename,content,line_number_debug, header_name_debug):
    if not os.path.isdir(path):
        os.makedirs(path)
    target_path=path+"/"+filename
    if os.path.isfile(target_path):
        handle_warning(fd.feof("repeated-header-warn", "Line {num}: repeated header info \"{name}\", overwriting", \
            num=str(line_number_debug), name=header_name_debug))
    f=open(target_path,'w', encoding="utf-8")
    f.write(content+'\n')

def write_infofile_v2(path: str, filename: str, content_phrases: list[str], line_number_debug: int, header_name_debug: str):
    if not os.path.isdir(path):
        os.makedirs(path)
    target_path=path+"/"+filename
    if os.path.isfile(target_path):
        handle_warning(fd.feof("repeated-header-warn", "Line {num}: repeated header info \"{name}\", overwriting", \
            num=str(line_number_debug), name=header_name_debug))
    f=open(target_path,'w', encoding="utf-8")
    for line in content_phrases:
        f.write(line+"\n")

def generate_custom_path():
    # Generate a temporary path
    global path
    path=_globalvar.clitheme_temp_root+"/clitheme-temp-"
    for x in range(8):
        path+=random.choice(string.ascii_letters)

# Returns true for success or error message
def generate_data_hierarchy(file_content, custom_path_gen=True, custom_infofile_name="1"):
    """
    Generate the data hierarchy in a temporary directory from a definition file (accessible with _generator.path)

    This function should not be invoked directly unless absolutely necessary.
    """
    if custom_path_gen:
        generate_custom_path()
    if not os.path.exists(path): os.mkdir(path)
    datapath=path+"/"+_globalvar.generator_data_pathname
    if not os.path.exists(datapath): os.mkdir(datapath)
    current_status="" # header, main, entry
    linenumber=0
    # To detect repeated blocks
    headerparsed=False
    mainparsed=False

    current_domainapp="" # for in_domainapp and unset_domainapp in main block
    current_entry_name="" # for entry
    current_subsection="" # for in_subsection

    current_entry_locale="" # for handling locale_block
    current_entry_linenumber=-1

    current_header_entry="" # for block input in header
    current_header_linenumber=-1

    blockinput=False # for multi-line (block) input
    blockinput_data="" # data of current block input
    blockinput_minspaces=-1 # min number of whitespaces
    for line in file_content.splitlines():
        linenumber+=1
        phrases=line.split()
        if blockinput==False and (line.strip()=="" or line.strip()[0]=="#"): # if empty line or comment (except in block input mode)
            continue

        if blockinput==True:
            if len(phrases)>0 and phrases[0]=="end_block":
                if blockinput_minspaces!=-1:
                    # process whitespaces
                    # trim amount of leading whitespaces on each line
                    pattern=r"(?P<optline>\n|^)[ ]{"+str(blockinput_minspaces)+"}"
                    blockinput_data=re.sub(pattern,r"\g<optline>", blockinput_data)
                if current_status=="entry":
                    for this_locale in current_entry_locale.split():
                        target_entry=current_entry_name
                        if this_locale!="default":
                            target_entry+="__"+this_locale
                        add_entry(datapath,target_entry, blockinput_data, current_entry_linenumber)
                    # clear data
                    current_entry_locale=""
                    current_entry_linenumber=-1
                elif current_status=="header":
                    if current_header_entry!="description":
                        # trim all leading whitespaces
                        blockinput_data=re.sub(r"(?P<optline>\n|^)[ ]+",r"\g<optline>", blockinput_data)
                        # trim all trailing whitespaces
                        blockinput_data=re.sub(r"[ ]+(?P<optline>\n|$)",r"\g<optline>", blockinput_data)
                        # trim all leading/trailing newlines
                        blockinput_data=re.sub(r"(\A\n+|\n+\Z)", "", blockinput_data)
                    filename="clithemeinfo_"+current_header_entry+"_v2"
                    if current_header_entry=="description":
                        filename="clithemeinfo_"+current_header_entry
                    write_infofile( \
                        path+"/"+_globalvar.generator_info_pathname+"/"+custom_infofile_name, \
                        filename,\
                        blockinput_data,current_header_linenumber,current_header_entry) # e.g. [...]/theme-info/1/clithemeinfo_description_v2
                    # clear data
                    current_header_entry=""
                    current_header_linenumber=-1
                else: # the unlikely case
                    handle_error(fd.feof("internal-error-blockinput", "Line {num}: internal error while handling block input; please file a bug report", num=str(linenumber)))
                # clear data
                blockinput=False
                blockinput_data=""
            else:
                if blockinput_data!="": blockinput_data+="\n"
                line_content=line.strip()
                if line_content=="": # empty line
                    if blockinput_data=="": blockinput_data+=" "
                    continue
                # Calculate whitespaces
                spaces=-1
                ws_match=re.search(r"^\s+", line) # match leading whitespaces
                if ws_match==None: # no leading spaces
                    spaces=0
                else:
                    leading_whitespace=ws_match.group()
                    # substitute \t with 8 spaces
                    leading_whitespace=re.sub(r"\t"," "*8, leading_whitespace)
                    # append it to line_content
                    line_content=leading_whitespace+line_content
                    # write line_content to data
                    blockinput_data+=line_content
                    spaces=len(leading_whitespace)
                # update min count
                if spaces!=-1 and (spaces<blockinput_minspaces or blockinput_minspaces==-1):
                    blockinput_minspaces=spaces
                
        elif current_status=="": # expect begin_header or begin_main
            if phrases[0]=="begin_header": 
                if len(phrases)!=1:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                if headerparsed:
                    handle_error(fd.feof("repeated-header-err", "Repeated header block at line {num}", num=str(linenumber)))
                current_status="header"
            elif phrases[0]=="begin_main": 
                if len(phrases)!=1:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                if mainparsed:
                    handle_error(fd.feof("repeated-main-err", "Repeated main block at line {num}", num=str(linenumber)))
                current_status="main"
            else: handle_error(fd.feof("invalid-phrase-err", "Unexpected \"{phrase}\" on line {num}", phrase=phrases[0], num=str(linenumber)))
        elif current_status=="header": # expect name, version, locales, or end_header
            if phrases[0]=="name" or phrases[0]=="version" or phrases[0]=="description":
                if len(phrases)<2:
                    handle_error(fd.feof("not-enough-args-err", "Not enough arguments for \"{phrase}\" at line {num}", phrase=phrases[0], num=str(linenumber)))
                content=splitarray_to_string(phrases[1:])
                write_infofile( \
                    path+"/"+_globalvar.generator_info_pathname+"/"+custom_infofile_name, \
                    "clithemeinfo_"+phrases[0],\
                    content,linenumber,phrases[0]) # e.g. [...]/theme-info/1/clithemeinfo_name
            elif phrases[0]=="locales" or phrases[0]=="supported_apps":
                if len(phrases)<2:
                    handle_error(fd.feof("not-enough-args-err", "Not enough arguments for \"{phrase}\" at line {num}", phrase=phrases[0], num=str(linenumber)))
                content=phrases[1:]
                write_infofile_v2( \
                    path+"/"+_globalvar.generator_info_pathname+"/"+custom_infofile_name, \
                    "clithemeinfo_"+phrases[0]+"_v2",\
                    content,linenumber,phrases[0]) # e.g. [...]/theme-info/1/clithemeinfo_description_v2
            elif phrases[0]=="locales_block" or phrases[0]=="supported_apps_block" or phrases[0]=="description_block":
                current_header_entry=re.sub(r"_block$", "", phrases[0])
                current_header_linenumber=linenumber
                blockinput=True # start block input mode
            elif phrases[0]=="end_header": 
                if len(phrases)!=1:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                current_status=""
                headerparsed=True
            else: handle_error(fd.feof("invalid-phrase-err", "Unexpected \"{phrase}\" on line {num}", phrase=phrases[0], num=str(linenumber)))
        elif current_status=="main": # expect entry, in_domainapp, unset_domainapp, end_main
            if phrases[0]=="entry":
                if len(phrases)<2:
                    handle_error(fd.feof("not-enough-args-err", "Not enough arguments for \"{phrase}\" at line {num}", phrase=phrases[0], num=str(linenumber)))
                # Prevent leading . & prevent /,\ in entry name
                if _globalvar.sanity_check(splitarray_to_string(phrases[1:]))==False:
                    handle_error(fd.feof("sanity-check-entry-err", "Line {num}: entry subsections/names {sanitycheck_msg}", num=str(linenumber), sanitycheck_msg=_globalvar.sanity_check_error_message))
                entry_name=splitarray_to_string(phrases[1:]) # generate entry name
                if current_subsection!="": entry_name=current_subsection+" "+entry_name
                if current_domainapp!="": entry_name=current_domainapp+" "+entry_name
                recursive_mkdir(datapath, entry_name, linenumber)
                current_status="entry"
                current_entry_name=entry_name
            elif phrases[0]=="in_domainapp": 
                if len(phrases)<3:
                    handle_error(fd.feof("not-enough-args-err", "Not enough arguments for \"{phrase}\" at line {num}", phrase=phrases[0], num=str(linenumber)))
                elif len(phrases)>3:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                # sanity check
                if _globalvar.sanity_check(phrases[1]+" "+phrases[2])==False:
                    handle_error(fd.feof("sanity-check-domainapp-err", "Line {num}: domain and app names {sanitycheck_msg}", num=str(linenumber), sanitycheck_msg=_globalvar.sanity_check_error_message))
                current_domainapp=phrases[1]+" "+phrases[2]
                current_subsection=""
            elif phrases[0]=="in_subsection":
                if len(phrases)<2:
                    handle_error(fd.feof("not-enough-args-err", "Not enough arguments for \"{phrase}\" at line {num}", phrase=phrases[0], num=str(linenumber)))
                # check if in_domainapp is set
                if current_domainapp=="":
                    handle_error(fd.feof("subsection-before-domainapp-err", "Line {num}: in_subsection used before in_domainapp", num=str(linenumber)))
                # sanity check
                if _globalvar.sanity_check(splitarray_to_string(phrases[1:]))==False:
                    handle_error(fd.feof("sanity-check-subsection-err", "Line {num}: subsection names {sanitycheck_msg}", num=str(linenumber), sanitycheck_msg=_globalvar.sanity_check_error_message))
                current_subsection=splitarray_to_string(phrases[1:])
            elif phrases[0]=="unset_domainapp":
                if len(phrases)!=1:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                current_domainapp=""
                current_subsection=""
            elif phrases[0]=="unset_subsection":
                if len(phrases)!=1:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                current_subsection=""
            elif phrases[0]=="end_main":
                if len(phrases)!=1:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                current_status=""
                mainparsed=True
            else: handle_error(fd.feof("invalid-phrase-err", "Unexpected \"{phrase}\" on line {num}", phrase=phrases[0], num=str(linenumber)))
        elif current_status=="entry": # expect locale, end_entry
            if phrases[0]=="locale":
                if len(phrases)<3:
                    handle_error(fd.feof("not-enough-args-err", "Not enough arguments for \"{phrase}\" at line {num}", phrase=phrases[0], num=str(linenumber)))
                content=splitarray_to_string(phrases[2:])
                target_entry=current_entry_name
                if phrases[1]!="default":
                    target_entry+="__"+phrases[1]
                add_entry(datapath,target_entry,content,linenumber)
            elif phrases[0]=="locale_block":
                if len(phrases)<2:
                    handle_error(fd.feof("not-enough-args-err", "Not enough arguments for \"{phrase}\" at line {num}", phrase=phrases[0], num=str(linenumber)))
                current_entry_locale=splitarray_to_string(phrases[1:])
                current_entry_linenumber=linenumber
                blockinput=True # start block input
            elif phrases[0]=="end_entry":
                if len(phrases)!=1:
                    handle_error(fd.feof("extra-arguments-err", "Extra arguments after \"{phrase}\" on line {num}", num=str(linenumber), phrase=phrases[0]))
                current_status="main"
                current_entry_name=""
            else: handle_error(fd.feof("invalid-phrase-err", "Unexpected \"{phrase}\" on line {num}", phrase=phrases[0], num=str(linenumber)))
    if not headerparsed or not mainparsed:
        handle_error(fd.reof("incomplete-block-err", "Missing or incomplete header or main block"))
    # Update current theme index
    theme_index=open(path+"/"+_globalvar.generator_info_pathname+"/"+_globalvar.generator_index_filename, 'w', encoding="utf-8")
    theme_index.write(custom_infofile_name+"\n")
    return True # Everything is successful! :)
